# Documentation
- Class name: EsheepImageSplit
- Category: tests
- Output node: False
- Repo Ref: https://github.com/esheep/esheep_custom_nodes.git

The node is designed to separate images into grid-shaped tiles based on the specified columns and rows, so that large images can be handled in a more manageable manner. By dissecting images into smaller parts, it enhances the workflow and allows for more focused analysis and operations.

# Input types
## Required
- images
    - The image parameter is essential because it provides the source data for node operations. It is the main input that determines the subsequent processing and production of tiles.
    - Comfy dtype: IMAGE
    - Python dtype: PIL.Image or torch.Tensor
- columns
    - The number of columns determines how the image is divided horizontally, directly affecting the order and number of tiles generated. It is an important parameter for controlling the particle size of the image.
    - Comfy dtype: INT
    - Python dtype: int
- lines
    - Similar to the number of columns, the number of rows determines the vertical partition of the image and affects the shape and number of tiles. It defines the grid structure in conjunction with the column number parameters.
    - Comfy dtype: INT
    - Python dtype: int

# Output types
- output
    - Output is a collection of tiles generated by a split input image. It represents the main result of the node operation and covers the processed data in a format that can be used further in the downstream task.
    - Comfy dtype: IMAGE
    - Python dtype: torch.Tensor

# Usage tips
- Infra type: CPU

# Source code
```
class EsheepImageSplit:

    def __init__(self):
        pass

    @classmethod
    def INPUT_TYPES(s):
        return {'required': {'images': ('IMAGE',), 'columns': ('INT', {'default': 2, 'min': 1, 'max': 100, 'step': 1, 'display': 'number'}), 'lines': ('INT', {'default': 3, 'min': 1, 'max': 100, 'step': 1, 'display': 'number'})}}
    RETURN_TYPES = ('IMAGE',)
    FUNCTION = 'execute'
    CATEGORY = 'tests'

    def execute(self, images, columns, lines):
        image = images[0]
        i = 255.0 * image.cpu().numpy()
        pil_image = Image.fromarray(np.clip(i, 0, 255).astype(np.uint8))
        imgwidth = pil_image.size[0]
        imgheight = pil_image.size[1]
        M = int(imgwidth / columns)
        N = int(imgheight / lines)
        tiles = []
        for i in range(0, imgheight - imgheight % N, N):
            for j in range(0, imgwidth - imgwidth % M, M):
                box = (j, i, j + M, i + N)
                tiles.append(pil_image.crop(box))
        t_tiles = []
        for tile in tiles:
            t_tile = tile.convert('RGB')
            t_tile = np.array(t_tile).astype(np.float32) / 255.0
            t_tile = torch.from_numpy(t_tile)[None,]
            t_tiles.append(t_tile)
        s = t_tiles[0]
        for i in range(1, len(t_tiles)):
            s = torch.cat((s, t_tiles[i]), dim=0)
        return (s,)
```