# Documentation
- Class name: RangeInt
- Category: EasyUse/Logic/Type
- Output node: False
- Repo Ref: https://github.com/yolain/ComfyUI-Easy-Use.git

The RangeInt class covers the logic of generating a series of integer numbers based on user-defined parameters, which facilitates the creation of numerical ranges for various applications.

# Input types
## Required
- range_mode
    - The range_mode parameter determines whether the range is generated by a fixed'step' size or a specified 'num_steps'. This is essential for determining the structure and distribution of the output range.
    - Comfy dtype: COMBO[str]
    - Python dtype: str
- start
    - Start parameters define the initial value of the range. It is essential because it sets the starting point for the generation of the integer sequence.
    - Comfy dtype: INT
    - Python dtype: int
- stop
    - The stop parameter specifies the upper limit of the range. It works with the start parameter and determines the range of the integer series.
    - Comfy dtype: INT
    - Python dtype: int
- step
    - The Step parameter sets the value of the increment between each element in the range. It significantly influences the process and spacing of the sequence.
    - Comfy dtype: INT
    - Python dtype: int
- num_steps
    - Num_steps parameters define the number of steps expected within the range. It is important for determining the particle size of the output sequence.
    - Comfy dtype: INT
    - Python dtype: int
- end_mode
    - End_mode parameters specify whether the cessation value in the range is included or not. This affects whether the upper limit is included in the generation sequence.
    - Comfy dtype: COMBO[str]
    - Python dtype: str

# Output types
- range
    - The range output is a list of integer values generated from input parameters, representing the value series within the defined range.
    - Comfy dtype: LIST[INT]
    - Python dtype: List[int]
- range_sizes
    - The range_sizes output provides an integer count for each individually generated range and provides insight into the distribution of values.
    - Comfy dtype: LIST[INT]
    - Python dtype: List[int]

# Usage tips
- Infra type: CPU

# Source code
```
class RangeInt:

    def __init__(self) -> None:
        pass

    @classmethod
    def INPUT_TYPES(s) -> Dict[str, Dict[str, Any]]:
        return {'required': {'range_mode': (['step', 'num_steps'], {'default': 'step'}), 'start': ('INT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 1}), 'stop': ('INT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 1}), 'step': ('INT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 1}), 'num_steps': ('INT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 1}), 'end_mode': (['Inclusive', 'Exclusive'], {'default': 'Inclusive'})}}
    RETURN_TYPES = ('INT', 'INT')
    RETURN_NAMES = ('range', 'range_sizes')
    INPUT_IS_LIST = True
    OUTPUT_IS_LIST = (True, True)
    FUNCTION = 'build_range'
    CATEGORY = 'EasyUse/Logic/Type'

    def build_range(self, range_mode, start, stop, step, num_steps, end_mode) -> Tuple[List[int], List[int]]:
        error_if_mismatched_list_args(locals())
        ranges = []
        range_sizes = []
        for (range_mode, e_start, e_stop, e_num_steps, e_step, e_end_mode) in zip_with_fill(range_mode, start, stop, num_steps, step, end_mode):
            if range_mode == 'step':
                if e_end_mode == 'Inclusive':
                    e_stop += 1
                vals = list(range(e_start, e_stop, e_step))
                ranges.extend(vals)
                range_sizes.append(len(vals))
            elif range_mode == 'num_steps':
                direction = 1 if e_stop > e_start else -1
                if e_end_mode == 'Exclusive':
                    e_stop -= direction
                vals = np.rint(np.linspace(e_start, e_stop, e_num_steps)).astype(int).tolist()
                ranges.extend(vals)
                range_sizes.append(len(vals))
        return (ranges, range_sizes)
```