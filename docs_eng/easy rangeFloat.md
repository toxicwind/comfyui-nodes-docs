# Documentation
- Class name: RangeFloat
- Category: EasyUse/Logic/Type
- Output node: False
- Repo Ref: https://github.com/yolain/ComfyUI-Easy-Use.git

This node facilitates the generation of a series of floating points within the specified range, depending on the pattern and parameters defined by the user. It gives an abstraction of the process of creating the range, allowing precise control of the starting value, the termination value and the length of the step, as well as the inclusion of the number of steps and endpoints.

# Input types
## Required
- range_mode
    - The mode parameter determines the logic used to generate the range sequence. It is necessary because it sets the operational context for the node and determines whether the range is generated by a fixed'step length' or a specified'step'.
    - Comfy dtype: COMBO[String]
    - Python dtype: str
- start
    - The starting parameter defines the initial value of the range. It is essential because it sets a baseline for the generation of the range sequence, affecting the output as a whole.
    - Comfy dtype: FLOAT
    - Python dtype: decimal.Decimal
- stop
    - The termination parameter marks the end point of the range. It is important because, together with the starting value, it defines the boundary at which the range sequence is generated.
    - Comfy dtype: FLOAT
    - Python dtype: decimal.Decimal
- step
    - The step parameter determines the increment between each value in the range sequence. Its value directly affects the particle size and pattern of the sequence.
    - Comfy dtype: FLOAT
    - Python dtype: decimal.Decimal
- end_mode
    - End mode parameters determine whether the termination value is included in the range sequence. This affects the inclusion of the endpoint, and thus the composition of the output.
    - Comfy dtype: COMBO[String]
    - Python dtype: str
## Optional
- num_steps
    - The steps parameter specifies the number of steps expected in the range series. It is important because it directly affects the number of values generated by nodes.
    - Comfy dtype: INT
    - Python dtype: int

# Output types
- range
    - The range output provides the resulting float number sequence, which is the core result of the node operation. It covers the essence of the range generation process.
    - Comfy dtype: LIST[FLOAT]
    - Python dtype: List[float]
- range_sizes
    - The range size output provides the number of values in each individually generated range sequence and provides insight into the distribution and structure of the output.
    - Comfy dtype: LIST(INT)
    - Python dtype: List[int]

# Usage tips
- Infra type: CPU

# Source code
```
class RangeFloat:

    def __init__(self) -> None:
        pass

    @classmethod
    def INPUT_TYPES(s) -> Dict[str, Dict[str, Any]]:
        return {'required': {'range_mode': (['step', 'num_steps'], {'default': 'step'}), 'start': ('FLOAT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 0.1}), 'stop': ('FLOAT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 0.1}), 'step': ('FLOAT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 0.1}), 'num_steps': ('INT', {'default': 0, 'min': -4096, 'max': 4096, 'step': 1}), 'end_mode': (['Inclusive', 'Exclusive'], {'default': 'Inclusive'})}}
    RETURN_TYPES = ('FLOAT', 'INT')
    RETURN_NAMES = ('range', 'range_sizes')
    INPUT_IS_LIST = True
    OUTPUT_IS_LIST = (True, True)
    FUNCTION = 'build_range'
    CATEGORY = 'EasyUse/Logic/Type'

    @staticmethod
    def _decimal_range(range_mode: String, start: Decimal, stop: Decimal, step: Decimal, num_steps: Int, inclusive: bool) -> Iterator[float]:
        if range_mode == 'step':
            ret_val = start
            if inclusive:
                stop = stop + step
            direction = 1 if step > 0 else -1
            while (ret_val - stop) * direction < 0:
                yield float(ret_val)
                ret_val += step
        elif range_mode == 'num_steps':
            step = (stop - start) / (num_steps - 1)
            direction = 1 if step > 0 else -1
            ret_val = start
            for _ in range(num_steps):
                if (ret_val - stop) * direction > 0:
                    break
                yield float(ret_val)
                ret_val += step

    def build_range(self, range_mode, start, stop, step, num_steps, end_mode) -> Tuple[List[float], List[int]]:
        error_if_mismatched_list_args(locals())
        getcontext().prec = 12
        start = [Decimal(s) for s in start]
        stop = [Decimal(s) for s in stop]
        step = [Decimal(s) for s in step]
        ranges = []
        range_sizes = []
        for (range_mode, e_start, e_stop, e_step, e_num_steps, e_end_mode) in zip_with_fill(range_mode, start, stop, step, num_steps, end_mode):
            vals = list(self._decimal_range(range_mode, e_start, e_stop, e_step, e_num_steps, e_end_mode == 'Inclusive'))
            ranges.extend(vals)
            range_sizes.append(len(vals))
        return (ranges, range_sizes)
```