# Documentation
- Class name: TwoAdvancedSamplersForMask
- Category: ImpactPack/Sampler
- Output node: False
- Repo Ref: https://github.com/ltdrdata/ComfyUI-Impact-Pack.git

The TwoAdvancedSamplersForMask node is designed to perform advanced sampling of potential images using two different high-level samplers. It uses mask corrosion techniques to fine-tune the mask and uses two independent high-level samplers to process the masked and uncovered area of the image. The node is designed to improve the quality of the image generated by using the advantages of the two samplers.

# Input types
## Required
- seed
    - Seed parameters are essential to the random number generation process, ensuring repeatability of sampling. It affects the initial state of the sampling algorithm and thus the potential images generated.
    - Comfy dtype: INT
    - Python dtype: int
- steps
    - The steps parameter defines the number of turns that the sampling process will experience. It is a key factor in determining the level of detail and the quality of the final image.
    - Comfy dtype: INT
    - Python dtype: int
- denoise
    - Noise parameters control the level of noise reduction applied during the sampling process. It plays an important role in generating the clarity and sharpness of the image.
    - Comfy dtype: FLOAT
    - Python dtype: float
- samples
    - Sample parameters save the initial potential image data to be processed by the sampler. It is an important part of the input, as it serves as the starting point for sampling operations.
    - Comfy dtype: LATENT
    - Python dtype: torch.Tensor
- base_sampler
    - The basic sampler parameter is specified as the advanced sampler that will be used to process the unfiltered area of the image. It is the key component for achieving the required sampling results.
    - Comfy dtype: KSAMPLER_ADVANCED
    - Python dtype: KSamplerAdvancedWrapper
- mask_sampler
    - The mask sampler parameter identification is used exclusively for advanced sampling of the image mask area. It is essential for the application of specific sampling techniques to the mask area.
    - Comfy dtype: KSAMPLER_ADVANCED
    - Python dtype: KSamplerAdvancedWrapper
- mask
    - The mask parameters provide the mask that will be applied to potential images to distinguish between the masked and uncovered areas. It is important to guide the sampling process.
    - Comfy dtype: MASK
    - Python dtype: torch.Tensor
## Optional
- overlap_factor
    - The overlapping factor parameter determines the extent of the mask corrosion and is used to create a buffer zone between the masked and uncovered area. It facilitates the smoothness of the transition in the final image.
    - Comfy dtype: INT
    - Python dtype: int

# Output types
- latent_image
    - Potential image output contains potential images that can be processed using advanced sampling techniques. It represents the end result of the sampling operation.
    - Comfy dtype: LATENT
    - Python dtype: torch.Tensor

# Usage tips
- Infra type: GPU

# Source code
```
class TwoAdvancedSamplersForMask:

    @classmethod
    def INPUT_TYPES(s):
        return {'required': {'seed': ('INT', {'default': 0, 'min': 0, 'max': 18446744073709551615}), 'steps': ('INT', {'default': 20, 'min': 1, 'max': 10000}), 'denoise': ('FLOAT', {'default': 1.0, 'min': 0.0, 'max': 1.0, 'step': 0.01}), 'samples': ('LATENT',), 'base_sampler': ('KSAMPLER_ADVANCED',), 'mask_sampler': ('KSAMPLER_ADVANCED',), 'mask': ('MASK',), 'overlap_factor': ('INT', {'default': 10, 'min': 0, 'max': 10000})}}
    RETURN_TYPES = ('LATENT',)
    FUNCTION = 'doit'
    CATEGORY = 'ImpactPack/Sampler'

    @staticmethod
    def mask_erosion(samples, mask, grow_mask_by):
        mask = mask.clone()
        w = samples['samples'].shape[3]
        h = samples['samples'].shape[2]
        mask2 = torch.nn.functional.interpolate(mask.reshape((-1, 1, mask.shape[-2], mask.shape[-1])), size=(w, h), mode='bilinear')
        if grow_mask_by == 0:
            mask_erosion = mask2
        else:
            kernel_tensor = torch.ones((1, 1, grow_mask_by, grow_mask_by))
            padding = math.ceil((grow_mask_by - 1) / 2)
            mask_erosion = torch.clamp(torch.nn.functional.conv2d(mask2.round(), kernel_tensor, padding=padding), 0, 1)
        return mask_erosion[:, :, :w, :h].round()

    def doit(self, seed, steps, denoise, samples, base_sampler, mask_sampler, mask, overlap_factor):
        inv_mask = torch.where(mask != 1.0, torch.tensor(1.0), torch.tensor(0.0))
        adv_steps = int(steps / denoise)
        start_at_step = adv_steps - steps
        new_latent_image = samples.copy()
        mask_erosion = TwoAdvancedSamplersForMask.mask_erosion(samples, mask, overlap_factor)
        for i in range(start_at_step, adv_steps):
            add_noise = 'enable' if i == start_at_step else 'disable'
            return_with_leftover_noise = 'enable' if i + 1 != adv_steps else 'disable'
            new_latent_image['noise_mask'] = inv_mask
            new_latent_image = base_sampler.sample_advanced(add_noise, seed, adv_steps, new_latent_image, i, i + 1, 'enable', recovery_mode='ratio additional')
            new_latent_image['noise_mask'] = mask_erosion
            new_latent_image = mask_sampler.sample_advanced('disable', seed, adv_steps, new_latent_image, i, i + 1, return_with_leftover_noise, recovery_mode='ratio additional')
        del new_latent_image['noise_mask']
        return (new_latent_image,)
```