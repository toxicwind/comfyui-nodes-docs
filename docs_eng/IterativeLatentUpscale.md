# Documentation
- Class name: IterativeLatentUpscale
- Category: ImpactPack/Upscale
- Output node: False
- Repo Ref: https://github.com/ltdrdata/ComfyUI-Impact-Pack.git

The 'doit' method at the IterativeLatentUpscale node is designed to scale up the potential expression of the sample through a specified number of iterative steps. Its intelligent application of the magnification factor to enhance the resolution of potential space may lead to improved detail in the magnification output. By fine-tuning the potential space, this method aims to achieve a higher quality magnification without compromising the bottom structure, thus contributing to the process.

# Input types
## Required
- samples
    - The “samples” parameter is essential because it provides an initial potential indication of the node to be magnified. Its quality and dimensions directly affect the ability of the node to produce high-resolution output. This parameter is essential for the iterative magnification process and determines the starting point for the enhancement.
    - Comfy dtype: LATENT
    - Python dtype: torch.Tensor
- upscale_factor
    - The "upscale_factor " parameter determines the extent to which the potential sample will be magnified. It is a key factor in controlling the expansion of the output of the final resolution. This parameter allows fine-tuning of the size of the potential space to meet the required output dimensions.
    - Comfy dtype: FLOAT
    - Python dtype: float
- steps
    - The Steps parameter defines the number of iterative magnification steps to be implemented. It is important because it determines the particle size of the iterative process and allows for a more controlled and gradual enhancement of potential space. An increase in the number of steps can lead to more smoother and finer magnification results.
    - Comfy dtype: INT
    - Python dtype: int
- upscaler
    - The "upcaler" parameter is a necessary input that provides a mechanism for magnifying potential samples. It contains the logic and operation necessary for an iterative magnification process and is essential for determining the efficiency and effectiveness of node functions.
    - Comfy dtype: UPSCALER
    - Python dtype: comfy_extras.nodes_upscale_model.Upscaler
## Optional
- temp_prefix
    - The "temp_prefix" parameter is used to specify prefixes for temporary files that may be created during the magnification process. Although not necessary, they may be useful in organizing or identifying intermediate files, especially in complex workflows involving multiple nodes.
    - Comfy dtype: STRING
    - Python dtype: str
- step_mode
    - The "step_mode" parameter sets out the method of increasing the size of each step of the iterative magnification process. It provides a simple choice of linear or geometric progress that can significantly influence the distribution of the details in the magnifying output.
    - Comfy dtype: COMBO[simple, geometric]
    - Python dtype: str
- unique_id
    - The “unique_id” parameter, although optional, can be used to track the progress and status of nodes in larger workflows. It is particularly useful when running multiple examples of nodes at the same time, allowing for the separation and monitoring of the execution of the nodes.
    - Comfy dtype: UNIQUE_ID
    - Python dtype: str

# Output types
- latent
    - The "latet" output represents a potential expression of magnification generated by an iterative process. It is a refined version of the input sample with an increased resolution that can be used for further processing or analysis.
    - Comfy dtype: LATENT
    - Python dtype: torch.Tensor
- vae
    - The "vae" output provides a VAE model associated with the potential expression of magnification. This model can be used for other tasks such as generating new samples for further analysis of potential space.
    - Comfy dtype: VAE
    - Python dtype: torch.nn.Module

# Usage tips
- Infra type: GPU

# Source code
```
class IterativeLatentUpscale:

    @classmethod
    def INPUT_TYPES(s):
        return {'required': {'samples': ('LATENT',), 'upscale_factor': ('FLOAT', {'default': 1.5, 'min': 1, 'max': 10000, 'step': 0.1}), 'steps': ('INT', {'default': 3, 'min': 1, 'max': 10000, 'step': 1}), 'temp_prefix': ('STRING', {'default': ''}), 'upscaler': ('UPSCALER',), 'step_mode': (['simple', 'geometric'], {'default': 'simple'})}, 'hidden': {'unique_id': 'UNIQUE_ID'}}
    RETURN_TYPES = ('LATENT', 'VAE')
    RETURN_NAMES = ('latent', 'vae')
    FUNCTION = 'doit'
    CATEGORY = 'ImpactPack/Upscale'

    def doit(self, samples, upscale_factor, steps, temp_prefix, upscaler, step_mode='simple', unique_id=None):
        w = samples['samples'].shape[3] * 8
        h = samples['samples'].shape[2] * 8
        if temp_prefix == '':
            temp_prefix = None
        if step_mode == 'geometric':
            upscale_factor_unit = pow(upscale_factor, 1.0 / steps)
        else:
            upscale_factor_unit = max(0, (upscale_factor - 1.0) / steps)
        current_latent = samples
        scale = 1
        for i in range(steps - 1):
            if step_mode == 'geometric':
                scale *= upscale_factor_unit
            else:
                scale += upscale_factor_unit
            new_w = w * scale
            new_h = h * scale
            core.update_node_status(unique_id, f'{i + 1}/{steps} steps | x{scale:.2f}', (i + 1) / steps)
            print(f'IterativeLatentUpscale[{i + 1}/{steps}]: {new_w:.1f}x{new_h:.1f} (scale:{scale:.2f}) ')
            step_info = (i, steps)
            current_latent = upscaler.upscale_shape(step_info, current_latent, new_w, new_h, temp_prefix)
        if scale < upscale_factor:
            new_w = w * upscale_factor
            new_h = h * upscale_factor
            core.update_node_status(unique_id, f'Final step | x{upscale_factor:.2f}', 1.0)
            print(f'IterativeLatentUpscale[Final]: {new_w:.1f}x{new_h:.1f} (scale:{upscale_factor:.2f}) ')
            step_info = (steps - 1, steps)
            current_latent = upscaler.upscale_shape(step_info, current_latent, new_w, new_h, temp_prefix)
        core.update_node_status(unique_id, '', None)
        return (current_latent, upscaler.vae)
```