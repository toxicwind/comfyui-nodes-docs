# Documentation
- Class name: SeargeSDXLSamplerV3
- Category: Searge/_deprecated_/Sampling
- Output node: False
- Repo Ref: https://github.com/jobunk/SeargeSDXL.git

The node is designed to implement the sampling process using a combination of base and fine-tuning models to generate high-quality potential images. It integrates noise and condition input to produce fine-tuned output and improves overall sampling efficiency and quality of results.

# Input types
## Required
- base_model
    - The base model is essential for building the infrastructure of the sampling process. It determines the initial conditions and possible changes in the process of generating potential images.
    - Comfy dtype: MODEL
    - Python dtype: UNetModel
- base_positive
    - This parameter, as positive condition data, influences the sampling process. It helps generate desired characteristics and improves the quality of output.
    - Comfy dtype: CONDITIONING
    - Python dtype: torch.Tensor
- base_negative
    - Negative condition data are used to bind the sampling process by avoiding undesirable characteristics. It plays a key role in ensuring that the final output is consistent with the desired direction.
    - Comfy dtype: CONDITIONING
    - Python dtype: torch.Tensor
- refiner_model
    - A fine-tuning model is essential for the reprocessing phase of the sampling process. It improves the quality and detail of the potential images generated by applying further refinements.
    - Comfy dtype: MODEL
    - Python dtype: UNetModel
- refiner_positive
    - The refinement of condition data is refining the output by highlighting certain characteristics. This is critical in achieving more detailed and targeted end results.
    - Comfy dtype: CONDITIONING
    - Python dtype: torch.Tensor
- refiner_negative
    - The fine-tuning of negative condition data helps to prevent undesirable elements from being introduced into the final output. It helps to improve the accuracy and accuracy of the sampling process.
    - Comfy dtype: CONDITIONING
    - Python dtype: torch.Tensor
- latent_image
    - The potential image is the initial input into the sampling process as a starting point. Its quality and characteristics significantly influence the final output.
    - Comfy dtype: LATENT
    - Python dtype: Dict[str, torch.Tensor]
- noise_seed
    - Noise seeds play an important role in controlling the randomity of noises applied during sampling. It ensures consistency and replicability of results.
    - Comfy dtype: INT
    - Python dtype: int
- steps
    - The number of steps determines the duration and complexity of the sampling process.
    - Comfy dtype: INT
    - Python dtype: int
- cfg
    - The configuration parameter is essential for adjusting the behaviour of the sampling process. It affects the balance between exploration and utilization, thereby achieving better results.
    - Comfy dtype: FLOAT
    - Python dtype: float
- sampler_name
    - Sampler name identification is a particular algorithm used in the sampling process. It is essential for achieving the desired characteristics in the final output.
    - Comfy dtype: SAMPLER_NAME
    - Python dtype: str
- scheduler
    - The scheduler controls the progress and adjustment of extra-parameters during the sampling process. It plays a key role in optimizing the efficiency of sampling and output quality.
    - Comfy dtype: SCHEDULER_NAME
    - Python dtype: str
- base_ratio
    - The base scale parameters influence the distribution of the steps between the base model and the refined model. It is essential to balance the rough and fine details in the ultimate potential image.
    - Comfy dtype: FLOAT
    - Python dtype: float
- denoise
    - Noise parameters control the level of noise reduction applied during the sampling process. It is important to improve the clarity and quality of the final output.
    - Comfy dtype: FLOAT
    - Python dtype: float
## Optional
- refiner_prep_steps
    - This optional parameter specifies the number of steps to be taken to refine the model. It can range from 0 to the total number of steps, allowing the pre-detailing process to be customized.
    - Comfy dtype: INT
    - Python dtype: int

# Output types
- latent
    - Outputs the potential image that ultimately emerges from the sampling process. It contains refined features and details achieved through a combination of underlying and fine-tuning models.
    - Comfy dtype: LATENT
    - Python dtype: Dict[str, torch.Tensor]

# Usage tips
- Infra type: GPU

# Source code
```
class SeargeSDXLSamplerV3:

    @classmethod
    def INPUT_TYPES(s):
        return {'required': {'base_model': ('MODEL',), 'base_positive': ('CONDITIONING',), 'base_negative': ('CONDITIONING',), 'refiner_model': ('MODEL',), 'refiner_positive': ('CONDITIONING',), 'refiner_negative': ('CONDITIONING',), 'latent_image': ('LATENT',), 'noise_seed': ('INT', {'default': 0, 'min': 0, 'max': 18446744073709551600}), 'steps': ('INT', {'default': 20, 'min': 1, 'max': 200}), 'cfg': ('FLOAT', {'default': 7.0, 'min': 0.0, 'max': 30.0, 'step': 0.5}), 'sampler_name': ('SAMPLER_NAME', {'default': 'ddim'}), 'scheduler': ('SCHEDULER_NAME', {'default': 'ddim_uniform'}), 'base_ratio': ('FLOAT', {'default': 0.8, 'min': 0.0, 'max': 1.0, 'step': 0.01}), 'denoise': ('FLOAT', {'default': 1.0, 'min': 0.0, 'max': 1.0, 'step': 0.01})}, 'optional': {'refiner_prep_steps': ('INT', {'default': 0, 'min': 0, 'max': 10})}}
    RETURN_TYPES = ('LATENT',)
    FUNCTION = 'sample'
    CATEGORY = 'Searge/_deprecated_/Sampling'

    def sample(self, base_model, base_positive, base_negative, refiner_model, refiner_positive, refiner_negative, latent_image, noise_seed, steps, cfg, sampler_name, scheduler, base_ratio, denoise, refiner_prep_steps=None):
        base_steps = int(steps * (base_ratio + 0.0001))
        refiner_steps = max(0, steps - base_steps)
        if denoise < 0.01:
            return (latent_image,)
        start_at_step = 0
        input_latent = latent_image
        if refiner_prep_steps is not None:
            if refiner_prep_steps >= base_steps:
                refiner_prep_steps = base_steps - 1
            if refiner_prep_steps > 0:
                start_at_step = refiner_prep_steps
                precondition_result = nodes.common_ksampler(refiner_model, noise_seed + 2, steps, cfg, sampler_name, scheduler, refiner_positive, refiner_negative, latent_image, denoise=denoise, disable_noise=False, start_step=steps - refiner_prep_steps, last_step=steps, force_full_denoise=False)
                input_latent = precondition_result[0]
        if base_steps >= steps:
            return nodes.common_ksampler(base_model, noise_seed, steps, cfg, sampler_name, scheduler, base_positive, base_negative, input_latent, denoise=denoise, disable_noise=False, start_step=start_at_step, last_step=steps, force_full_denoise=True)
        return sdxl_ksampler(base_model, refiner_model, noise_seed, base_steps, refiner_steps, cfg, sampler_name, scheduler, base_positive, base_negative, refiner_positive, refiner_negative, input_latent, denoise=denoise, disable_noise=False, start_step=start_at_step, last_step=steps, force_full_denoise=True)
```